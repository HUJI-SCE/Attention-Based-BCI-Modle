I want to design a neural network to preform BCI analysis data I have acquired from a brain science experiment from an EEG.
the neural network will work as follows:

Files in this directory ('neural_net_demo'): the original file was of type .bdf,
and was converted to .fif as it is allot smaller and speeds up testing.
The files in the directory are:
- 'neural_net_demo/data':
    1. data_lab.py - runs a simple plotting function for the data.
    2. raw_complete.fif - contains all the data pertaining to one session(one subject(named BIJVZD)
                       recorded for ~1.5 hours)
    3. raw_partial_30s.fif - contains the first 30 seconds of the data
    4. data_notes.txt - reserved for general notes about the data that might be important later.
    5. 'neural_net_demo/data/unpickle_data':
        a. BIGVZD_spmusclass.bdf - the original bdf file containing all the data of the session.
        b. draw_bdf_data.py - contains a function that crops the data and generates .fif files
        for faster testing (this function takes a long time to run, and so gets a file of it's own).
- 'neural_net_demo/labs': this directory contains labs - python file for experimenting with libraries
  like numpy, pyplot, mne, express, ...
- cnn.py - this is a simple and primitive prototype for a convolutional neural network.
  This network is not a draft for the end result of the project.
  It's topology will is described bellow.
- documentation.txt - this file.

The Data: The data is made out of 144 inputs and divided into 3 parts:
 - the EEG electrodes: 128 brainwave electrodes readings at a rate of 512HZ over an interval
 of 1.5 hours(~6000 seconds) - this is a matrix of 128x(~3072000)(float type) samples.
 - bio-sensory data: 15 (of the 16 remaining) electrodes recording data (such as breathing, blood pressure, blinking, â€¦),
 which will also be fed into the neural network.
 The units of measurement don't matter here (whether they are PSI for the blood pressure,
 voltage readings between two points on an organ, or anything else),
 these 15 electrodes are assumed to be a 15x3072000 float type matrix,
 and the network is expected to figure out unit conversion on it's own.

>NOTE: in future demos normalize all values to units that make sense in the calculation

 - keypress data: The final electrode(which is not really an electrode,
 but a bit for each sample(a bit for every 1/512 of a second))
 represents whether the space-bar was pressed during the instance of the sampling,
 the data is 1 if the key was pressed during the EEG reading and 0 if it wasn't.


Dividing the Data:
The Brainwave Electrodes:
a window of 300ms of measurement, which at a rate of 512Hz is 150 timestamps,
and over 128 electrodes becomes 131,072 samples(2*512Hz*128electrodes = 131,072).
The first window will contain the first 150 timestamps(of the 128 electrodes),
the second window will contain timestamps 2 to 151, the 3rd will contain 3-152 and so on.
Every window is fed separately into the CNN and is run through a forward propagation, at the end of which,
the output neuron(a single neuron with a value between 0 and 1) is compared to a binary 1/0
representing whether the space-bar is pressed.
This way, the CNN can learn to identify 300ms intervals where there was a space-bar press, and ones where there wasn't.


The input layer:
>NOTE: No validation set is used in this demo for time consumption reasons
>NOTE: The number of kernels was (predominantly) arbitrarily chosen to be 10.
In later demos, a different number should be chosen using the validation set.

The Electrode Kernels - the electrode kernels are a series of 10 kernels which will be applied to each electrode in a window.
The 1st batch: the first 150 samples from the 1st electrode will go through 10 kernels,
and the first 150 samples from the 2nd electrode will go through 10 different kernels, and so on until the 128th electrode.
The neural network will finish running this batch to the output layer, and then the second batch will begin.
In the 2nd batch: samples 2-151 from the 1st electrode will go through 10 kernels,
and the samples 2-151 from the 2nd electrode will go through 10 different kernels, and so on...
and so on...
This means that there will be a total of kernel_count*electrode_count kernels
in the first layer(as well as nodes in the 2nd layer) of the network, where kernel_count=10 and electrode_count=128.

The kernels will start off with random weights between -1 and 1,
 and will adjust according to backpropagation from the training process.
The nodes in the 2nd layer will also have biases which will start off at random values between -1 and 1.
The nodes will have no activation function(the activation function will be the unit function -
I want to see the values the nodes will return before specifying an activation function).


The Bio-Sensory Electrodes:
>NOTE: Bio-Sensory data like heartbeat, breathing, blinking, etc.. are only of interest to us in the sense of noise reduction.
If a brainwave electrode picked up higher voltage changes due to the subject blinking, we would like to be able to detect
the activity pertaining to a key press that may have happened during the blink, or at the least ignore the data completely
rather than evaluate it as some kind of computer operation.

We pool each bio-sensory electrode window(the 150 saplings from a bio-sensory
electrode) to a single node in a sub-secondary layer and copy that node to each of the brainwave kernels(the 10 electrodes
that multiply the brainwave electrodes).
This means that from the blinking electrode, 150 values of data will link to a single node(with initially random weights)
and that node will be copied to each kernel.
Making each kernel have 15 extra weights: kernel_size = samples_per_batch + bio_sensory_electrode_count.
where samples_per_batch=150 and bio_sensory_electrode_count=15.

!NOTE
In this demo we are assuming that the network doesn't interpret heartbeats/blinking/... in association with different
parts of the brain, differently.
If a part of the brain of the subject, say the frontal lobe, is showing brain activity resembling a keypress,
but is also showing brain activity relating to the beating of the heart - the overlapping may cause interference which
will hinder the network from interpreting the keypress activity as a keypress.
But because this heartbeat brain activity is so unique, it will cause a very unique kind of interference, one that demands
a very unique kernel to interpolate whether keypress brain activity is present or not.
A different part of the brain, say the parietal lobe will show brain activity with different signatures for keypress and
heartbeat, and thus would require a very different kernel to interpolate.
But the single number representing the heartbeat(the node to which all 150 samples in the window were pooled into), should
be the same for all kernels.

In future demos a better estimation of this heartbeat scalar should be found, this should be done by investigating heartbeat
behaviour from the electrode, and surmising a calculation that is perhaps better suited than the weighted average in this demo.
NOTE!

The 3rd layer:
The 3rd layer will contain 10 nodes.
Every node in the 2nd layer will link to every node in the 3rd layer.
In this layer, just like in the kernels in the previous layer, the weights will be random values between -1 and 1,
the biases will be random values between -1 and 1, and there will be no activation function.

The output layer:
The 4th layer will contain 1 node that will be linked from all 10 nodes from the previous layer.
This layer will also have random weights between -1 and 1, a random bias between -1 and 1 and no activation function.

The Label set:
During a batch interval(the 300ms encompassing the 150 samples in a batch) every sample will either coincide with
a keypress or it won't. Most probably the key-presses will last between 40-150 samples(~ 80ms-300ms), if the last sample
in an interval coincides with a keypress then the label for that interval will be 1, otherwise it will be 0.

>NOTE: in future demos, a more forgiving labeling system is recommended, perhaps one that labels intervals which precede
key-presses by a few dozen ms |0 0 0 ... 0| 0 0 1 1 1 ... 1 or ones which contain key-presses which end a few dozen ms
before the end of the interval  |0 0 .. 0 1 1 .. 1 0 0|, or giving a middle answer to before/after key-presses
( |0 0 0 ... 0| 1/4 1/2 1 1 1 ... 1 and |0 0 .. 1/4 1/2 1 1 .. 1 1/2 1/4 0| ).
This way, even if the network guesses a key press a little before or a little after an actual key press it could still count.

The Output Layer and the Error Function:
The one node in the output layer is compared to the label of the batch and triggers the backpropagation with MSE error function.